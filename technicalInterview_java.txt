OOP란? 객체 지향 프로그래밍이란 ?
객체와 객체의 유기적인 상호작용을 통해 프로그램이 동작하는 것. 여기서 객체란 현실의 물체를 의미함. 사람의 사고와 가장 비슷하게 프로그래밍 가능 함.
하나의 클래스를 바탕으로 서로 다른 상태의 인스턴스를 만들면서 다른 행동들을 하게 할 수 있음.
= 코드의 재사용 가능(재활용성), 유지 보수에 용이 ㅔ함.
↔ 절차지향 : 순차적인 처리 중시. 프로그램 전체가 유기적으로 연결. C언어. 컴퓨터 작업 처리 방식과 유사함.

자바 장점
자바 가상 머신 위에서 동작하기 때문에 OS에 독립적임.
아파치, 스프링과 같은 자바를 지원하는 많은 오픈 소스 프로젝트 존재해서 짧은 개발 시간 내에 안정적인 프로그램 구현 가능.
단점으로는 비교적 속도가 느리다는게 있지만 하드웨어 성능의 발전으로 JVM 기능의 향상 > 속도의 격차가 많이 줄어들었음.

메모리 영역?
메소드 영역 : static 변수, 전역변수, class 정보들 저장.
stack : 지역변수, 함수(메서드) 등이 할당
heap : new 연산자를 통한 동적 할당 된 객체 저장. 가비지 컬렉션에 의해 관리.

Primitive type vs Reference type
기본형 (primitive) : stack 메모리 영역에 실제 값을 저장하는 데이터 타입. byte, short, int, long, float, doublle, char, boolean / call by vaue 호출 방식을 사용함.
참조형 (reference) : 메모리 상에 객체가 있는 위치를 저장하는 것. String, 클래스, 인터페이스 .. new 연산자로 정의. 실제 값은 heap에 저장되고 stack에는 메모리 주소만 저장. call by reference

가비지 컬렉션?
시스템에서 더 이상 사용하지 않는 동적 할당된 메모리 블록을 찾아 다시 사용 가능한 자원으로 회수하는 것. 자동으로 이루어지므로 메모리 영역 관리 할 필요 없음.

전역변수 vs 지역변수
전역변수 : 함수 바깥에 선언하여 클래스 전체에서 사용가능한 변수. 여러 메소드에서 공통적으로 공통적으로 사용 가능.
지역변수 : 함수 속에서 선언하여 해당 함수 속에서만 사용가능한 변수.

static 의미?
정적 멤버 (static) : 메모리 공간 할당 시 처음 설정된 메모리 공간이 변하지 않는 것.
객체를 생성하지 않고도 사용할 수 있는 필드와 메소드. 객체마다 가지고 있을 필요가 없는 공용적인 데이터라면 static으로 선언.
객체 생성을 하지 않고 사용 가능하기 때문에 인스턴스 필드, 메소드를 내부에서 사용 할 수 없음.

String vs StringBuffer vs StringBuilder
String은 new 연산자를 통해 생성되면 인스턴스 메모리 공간이 절대 변하지 않으므로 +, concat과 같은 연산시 메모리의 내용이 변하는 것이 아니라 새로운 String 인스턴스가 생성됨. 이렇게 새로운 문자열이 만들어지면 기본의 문자열은 가비지 콜렉터에 의해 제거되야 함. 문자열 연산이 많아지는 경우 성능이 떨어짐. 하지만 불변하기 때문에 조회가 빠르고 멀티스레드 환경에서 동기화를 신경 쓸 필요 없음.
StringBuffer와 StringBuilder는 String과 다르게 클래스는 한 번만 만들고 메모리의 값을 변경시켜서 문자열을 변경함. 그러므로 문자열 연산이 자주 있을 때 사용하면 좋음.
StringBuffer은 멀티 스레드 환경에서 synchronize 키워드가 가능하므로 동기화가 가능하다. StringBuilder는 동기화를 지원하지 않기 때문에 멀티 스레드 환경에서 적합하지 않음.

접근제한자
public : 모든 클래스 접근 가능
protected : 같은 패키지, 해당 클래스를 상속받은 외부 패키지의 클래스
default : 같은 패키지에서만 접근 가능
private : 같은 클래스에서만 접근 가능

객체란?
우리 주위의 모든 데이터와 기능을 가진 것들이 객체가 될 수 있음.
ex) 식당에서 주문의 과정에서 종업원, 손님, 주문서, 메뉴판 ..

클래스/인스턴스란?
클래스란? 설계도. 클래스를 통해서 인스턴스 객체 생성 가능.
인스턴스 : 객체가 메모리에 할당되어 실제 메모리를 차지 하는 것.


추상 클래스란?
추상 메소드를 하나 이상 가진 클래스
자식 클래스에게 강제성 부여 가능. 이를 통해서 기능 확장 가능.
직접적으로 객체 생성이 불가능하고 클래스를 상속 받아서 오버라이딩하여 사용해야 함.
인터페이스란 ?
모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스
ex) 키보드. 키보드를 누른다 라는 행위는 같지만 엔터/스페이스바를 눌렀을 때의 결과는 다름. 메소드는 같지만 동작 방식은 다르게 다형성을 주고 싶은 경우 사용.
협업시 객체의 내부 구조를 모르더라도 인터페이스의 메서드 명만 알면 사용 가능 = 협업에 유리.
interface, implements, abstract pubilc 메소드, public static final 상수
다중 구현 가능.

추상 클래스와 인터페이스의 차이점은 ?
목적이 다름. 추상 클래스는 추상 메서드를 자식 클레스가 구체화해서 기능 확장에 목적이 있지만 인터페이스는 서로 관련이 없는 클래스에서 공통적으로 사용하는 방식이 필요하지만 기능은 각각 구현해야 하는 경우에 사용.
추상 클래스는 단일 상속, 인터페이스는 다중 구현 가능.

오버라이딩 vs 오버로딩
오버라이딩이란 상속에서 나온 개념. 부모 클래스의 메소드를 자식 클래스의 메소드로 재정의 하는 것. 기능의 확장을 위해서 사용 함.
오버로딩이란 같은 클래스 내에서 같은 이름의 메소드를 여러개 정의 하는 것으로 매개변수의 타입이 다르거나 개수가 다름. return 타입과 접근 제한자는 영향 없음.

다형성이란?
하나의 클래스나 함수가 다양한 방식으로 동작 가능 한 것. 오버라이딩과 오버로딩을 통해서 다형성 구현 가능. ex) 게임 > 다양한 캐릭터들에 대해서 동일한 버튼을 클릭해서 다른 스킬을 사용하게 하는 것.
캡슐화 : 데이터 보호, 불필요한 부분은 감출 수 있음.

상속이란 ?
부모 클래스가 가지고 있는 상수, 메소드를 자식 클래스에서 물려 받아 같이 공유하면서 확장하는 것
자식 클래스의 부모 클래스 메소드 재정의 > 오버라이딩
코드 중복 방지, 공통적인 코드 변경 할 때 시간 단축 가능.

쓰레드란 ?
프로세스 내에서 실제로 작업을 수행하는 주체를 의미하며 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행함. 두개 이상 스레드를 가지는 프로세스를 멀티 스레드 프로세스라고 함.
Thread 클래스, Runnable 인터페이스를 통해 구현 가능
장점 : 빠른 프로세스 생성 가능, 정보 쉽게 공유 가능.
단점 : 교착 상태 : 다중 프로그래밍 체제에서 하나 또는 그 이상의 프로세스가 수행 할 수 없는 어떤 특정 시간을 기다리고 있는 상태.
멀티 스레드 : 하나의 프로그램에서 둘 이상의 작업이 필요한 경우 사용.

JDBC란?
자바에서 DB의 종류에 상관 없이 데이터베이스에 더욱 쉽게 접근 할 수 있도록 하는 API.
Connection, PreparedStatement, ResultSet 등 여러개의 클래스를 생성하고 Exception 처리도 해야 하는 번거로움이 있음 > 반복적인 코드 발생, 생산성 저하.
Spring JDBC : 기존의 JDBC 단점 극복, 반복적으로 해야 하는 많은 작업들을 대신 해줌. Connection 열기 닫기, Statement 준비, 실행
ConnectionPool : DB와 항상 연결되어 있는 객체들. DB와의 연결을 위해서 사용하는 객체
DataSource : ConnectionPool 관리 객체. 커넥션풀 이용해서 연결, 반납하는 작업 수행.
pom.xml에서 dependency 추가
싱글톤
하나의 클래스에 대해 하나의 인스턴스만 만들어서 사용하기 위한 패턴. 커넥션 풀과 같은 객체의 경우 인스턴스를 여러개 만들게 되면 자원 낭비가 되므로 하나만 생성하는 것이 효율적.
생성자에 private 접근 제어자를 지정해 인스턴스 생성에 제약을 걸고, 단일 객체를 반환 할 수 있도록 정적 메소드를 지원해야 함.


제너릭?
클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법.
코드의 안정성과 재사용성을 높여줌 > 객체 타입을 컴파일 시에 체크하고, 형변환을 하지 않아도 됨.
ex) ArrayList<String> : ArrayList 객체 내부에 어떤 형태의 클래스가 있는지 확인 가능.

컬렉션?
다수의 데이터를 다루는데 표준화된 클래스들을 자료구조를 직접 구현하지 않고 편하게 사용 가능 함.
배열과 다르게 객체를 보관하기 위한 공간을 미리 정의하지 않아도 됨 > 객체의 수를 동적으로 할당 가능하므로 효율성 증대.
List, Set, Map (인터페이스)
List : 순서 있는 데이터의 집합. 데이터의 중복 허용.
ArrayList : 단방향 포인터 구조. 각 데이터에 대한 인덱스를 가짐. 검색에 적합. 삽입, 삭제시 데이터 이후 모든 데이터가 복사 됨으로 빈번한 경우에는 부적합.
LinkedList : 양방향 포인터 구조. 데이터의 삽입, 삭제시 해당 노드의 주소지만 바꾸면 되므로 삽입, 삭제가 빈번한 데이터에 적합. 처음부터 노드 순회하므로 검색에는 부적합.
Set : 순서를 유지하지 않는 데이터 집합. 데이터 중복 허용하지 않음.
HashSet :
TreeSet ;
Map : Key와 value의 쌍으로 이루어진 데이터 집합. 키는 중복을 허용하지 않고 순서를 유지하지 않음.
HashMap
containsKey / containsValue : key와 value가 포함되어 있는지 알려준다.
put : key, value 형태로 set에 저장함.
get : 지정된 key값을 반환함.
size() : 개수 반환
== / equals() 차이
== : 주소 값 비교
equals : 내용 비교
length , length(), size()
length : 배열 / length() : 문자열 길이 / size() : 컬렉션 프레임워크(arraylist) 타입의 길이

JDK / SDK
JDK (Java Developmnet Kit) : 자바 프로그램 개발도구. 자바 애플리케이션을 구축하기 위한 핵심 플랫폼 구성 요소.
SDK (Software Development Kit) : 개발을 위한 클래스, 컴파일러, 실행도구, 디버깅 툴, 예저 코드, 튜토리얼 등을 모아놓은 환경을 제공하는 것.



